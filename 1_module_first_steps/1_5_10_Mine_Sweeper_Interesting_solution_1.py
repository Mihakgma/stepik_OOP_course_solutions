"""
Оптимизированное решение:

1. Для быстрой генерации координат мин имеет смысл исключить возможность повторной генерации одних и тех же координат,
потому что теоретически таких сопадений может произойти сколько угодно и цикл генерации координат будет матать лишние
обороты до первого несовпадения. Один из способов избавится от этого явления - использовать метот random.sample,
который вибирает случайным образом заданное кол-во элементов из списка. Проблема в том,
что число мин M может быть больше размерости N, поэтому выбор M координат из списка чисел от 0 до N-1 тут не поможет.
Однако само игровое поле состоит из
�
2
N
2
   клеток. Если эти клетки последовательно пронумеровать то из списка их номеров можно будет выбрать случайным образом
   M методом sample, а затем каждый такой номер клетки можно преобразовать
   в соотвествующую пару координат на игровом поле!

2. Для того чтобы посчитать кол-во мин в соседних полях совсем не обязательно обходить все клетки поля.
Вместо этого можно обходить поля с минами и добавлять по единичке в соседние с ней поля! Так будет эффективнее,
потому что обычно кол-во мин заметно меньше, чем общее кол-во клеток на поле, в противном случе у игрока
не будеть шансов выграть подобную игру :).

Все эти действия можно выполнить в фунцкии init во время генерации мин и заполнения ими игрового поля.
"""


import random as rnd
import itertools

class Cell:
    def __init__(self, around_mines=0, mine=False):
        self.around_mines = around_mines
        self.mine = mine
        self.fl_open = False

class GamePole:
    def __init__(self, N, M):
        self.size = N
        self.num_mines = M
        self.pole = [[Cell() for _ in range(N)] for _ in range(N)]
        self.init()

    def init(self):
        for idx in rnd.sample(range(self.size ** 2), self.num_mines):
            i, j = divmod(idx, self.size)
            self.pole[i][j].mine = True
            for di, dj in itertools.product((-1, 0, 1), repeat=2):
                if all(0 <= coord < self.size for coord in (i + di, j + dj)):
                    self.pole[i + di][j + dj].around_mines += 1

    def show(self):
        for row in self.pole:
            print(*('#' if not cell.fl_open else '*' if cell.mine else cell.around_mines for cell in row))

if __name__ == '__main__':
    pole_game = GamePole(10, 12)
